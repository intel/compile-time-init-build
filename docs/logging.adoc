
== The `logging` library

See code at
https://github.com/intel/compile-time-init-build/tree/main/include/log.
Everything in the logging library is in the `logging` namespace, although most
user code will use macros.

Logging in `cib` is in two parts:

- the interface, in https://github.com/intel/compile-time-init-build/tree/main/include/log/log.hpp[log.hpp]
- an implementation, which can be specified at the top level

Three possible logger implementations are provided:

- one using fmt in https://github.com/intel/compile-time-init-build/tree/main/include/log/fmt/logger.hpp[fmt/logger.hpp]
- one using binary encoding in https://github.com/intel/compile-time-init-build/tree/main/include/log/catalog/encoder.hpp[catalog/encoder.hpp], using the https://www.mipi.org/specifications/sys-t[MIPI Sys-T spec] by default
- the default implementation: the null logger which accepts everything, but never produces output

=== Getting started

To get started using CIB logging, include `log.hpp` and use a log macro to output logs:
[source,cpp]
----
#include <log/log.hpp>

auto func() {
  CIB_INFO("Calling func");
}
----

And link against the `cib_log` library:
[source,cmake]
----
target_link_libraries(my_lib PUBLIC cib_log)
----

This is suitable usage for a library header. Notice: this code has not yet made
any decision about which logging implementation to use. And in fact the default
logger will produce no output.

To select a logging implementation for an application, we need to include the
appropriate implementation header and specialize a variable template:
[source,cpp]
----
#include <log/fmt/logger.hpp>
#include <iostream>

template <>
inline auto logging::config<> =
    logging::fmt::config{std::ostream_iterator<char>(std::cout)};
----

And of course link against the appropriate library:
[source,cmake]
----
target_link_libraries(my_app PUBLIC cib_log_fmt)
----

This will mean that the application uses the fmt logger to output to
`std::cout`. Any header-only library code that uses the log macros will
automatically use the correct logger.

The provided fmt logger implementation can output to multiple destinations by
constructing `logging::fmt::config` with multiple `ostream` iterators.

CAUTION: If you have multiple translation units, all TUs that use logging must
see the same specialization of the `logging::config` variable template --
otherwise you will have an ODR violation. This includes any compiled (not
header-only) library code.

=== Log levels
`cib` offers 6 well-known and 2 user-defined log levels, according to the
https://www.mipi.org/specifications/sys-t[MIPI Sys-T spec].

[source,cpp]
----
enum struct level {
    MAX = 0,
    FATAL = 1,
    ERROR = 2,
    WARN = 3,
    INFO = 4,
    USER1 = 5,
    USER2 = 6,
    TRACE = 7
};
----

C++ does not allow inheritance from an enumeration type, but one way to name
the user-defined levels is to use a `struct` to contain the enumeration values:

[source,cpp]
----
struct app_level {
    using enum logging::level;
    constexpr static auto APP1 = USER1;
};
----

There are other possibilities, but this "scopes" the enumeration values for the
application while keeping the type (`logging::level`) the same so that library
functions still work.

=== Log macros

`cib` log macros follow the log levels:
[source,cpp]
----
CIB_TRACE(...);
CIB_INFO(...);
CIB_WARN(...);
CIB_ERROR(...);
CIB_FATAL(...);
----

These macros are defined using the lower level macro `CIB_LOG_WITH_LEVEL`, so to
provide a new macro using a user-defined log level can be done:
[source,cpp]
----
#define LOG_APP1(...) CIB_LOG_WITH_LEVEL(app_level::APP1 __VA_OPT__(, ) __VA_ARGS__)
----

`CIB_FATAL` causes a call to
https://intel.github.io/cpp-std-extensions/#_panic_hpp[`stdx::panic`], and
`CIB_ASSERT(expression)` is equivalent to `CIB_FATAL` in the case where the
expression evaluates to `false`.

=== Log formatting
Under the hood, `cib` uses https://github.com/fmtlib/fmt[`fmt`] to format logs
before outputting them. All formatting that can be done at compile time, is done
at compile time. Some examples:

[source,cpp]
----
CIB_INFO("The answer is: {}", 42);   // compile-time formatted
CIB_INFO("The answer is: {}", "42"); // compile-time formatted

static constexpr auto x = 42;
CIB_INFO("The answer is: {}", x);    // compile-time formatted
CIB_INFO("42 is an {}", 42, int);    // compile-time formatted

auto y = 42;
CIB_INFO("The answer is: {}", y);    // runtime formatted
CIB_INFO("{} is an {}", y, int);     // compile-time (int) and runtime (y) formatted
----

NOTE: We can pass types as well as values to the log macros for formatting.
Types are converted to string representations.

=== Binary loggers
An application can select the binary logger by specializing the
`logging::config` variable template and providing a destination that will
receive binary data:
[source,cpp]
----
#include <log/catalog/encoder.hpp>
#include <stdx/span.hpp>

struct log_destination {
    template <std::size_t N>
    auto operator()(stdx::span<std::uint32_t const, N> data) const {}
};

template <>
inline auto logging::config<> = logging::binary::config{log_destination{}};
----

And linking against the binary log library:
[source,cmake]
----
target_link_libraries(my_app PUBLIC cib_log_binary)
----

The log destination must provide a function call operator (`operator()`) that
receives a span of the binary data to be written.

==== The build process

On a constrained system, space for text can be limited-to-nonexistent. The
`cib_log_binary` library encodes strings at build time so that string IDs are
sent at runtime and string data is not stored in the executable.

- First, each string constant contains string character data in its type.
- The binary logger calls the function template specialization
  https://github.com/intel/compile-time-init-build/blob/main/include/log/catalog/catalog.hpp[`catalog`]
  to get the ID corresponding to each string constant.

But: the `catalog` function template is just that -- only a template -- to
begin with. It is specialized as follows:

- The application is built as a library.
- Running `nm` on that library reveals missing symbols: precisely the function
  specializations that are required for all the string constants.
- Those symbols are used to generate the template specializations in another
  file, which itself is compiled into a library.
- String data is recovered from the symbol types and used to generate the
  catalog collateral in XML and/or JSON format.
- Link-time optimization inlines the `catalog` function template
  specializations, each of which is a one-line function that returns an ID.

mermaid::log_build_process.mmd[format="svg" config="mermaid.conf"]

NOTE: No logging exists in `main.cpp`: it's just a stub providing `main` that
calls into the application's library code.

Thus no string data exists in the executable, but the correct IDs are used for
logging, and at runtime a log decoder can reconstitute the actual strings. The
XML and JSON collateral also contains information about any runtime arguments
that need to be interpolated into the string and whose values are sent by the
binary logger along with the ID.

==== Tooling support

The process of generating log strings from the type information revealed by
missing symbols is automated by a
https://github.com/intel/compile-time-init-build/blob/main/tools/gen_str_catalog.py[python
script] provided and by a
https://github.com/intel/compile-time-init-build/blob/main/cmake/string_catalog.cmake[CMake
wrapper function (`gen_str_catalog`)] that drives the process. See
https://github.com/intel/compile-time-init-build/blob/main/test/CMakeLists.txt[the
test] that exercises that functionality for an example.

`gen_str_catalog` is the CMake function that drives the string catalog generation.

[source,cpp]
----
gen_str_catalog(
    GEN_STR_CATALOG <python-file>
    OUTPUT_CPP <output-cpp-file>
    OUTPUT_JSON <output-json-file>
    OUTPUT_XML <output-xml-file>
    INPUT_LIBS <lib-files...>
    INPUT_JSON <json-files...>
    STABLE_JSON <json-files...>
    INPUT_HEADERS <header-files...>
    CLIENT_NAME <client-name>
    VERSION <version>
    GUID_ID <guid>
    GUID_MASK <guid>
    MODULE_ID_MAX <max-id>
    OUTPUT_LIB <target-name>
    OUTPUTS_TARGET <target-name>
    FORGET_OLD_IDS)
----
- `INPUT_LIBS` is a required argument: this will be the input libraries from which the undefined symbols are extracted.
- `OUTPUT_{CPP,JSON,XML}` are the generated files. Also required.
- `INPUT_JSON` is optional extra JSON that will be copied verbatim into the generated JSON.
- `STABLE_JSON` is optional information about stable string and module IDs -- for example, from a previous build.
- `INPUT_HEADERS` are C++ header files that are `#include`​d in the `OUTPUT_CPP` file.
- `CLIENT_NAME`, `VERSION`, `GUID_ID` and `GUID_MASK` are all optional input fields for the MIPI-SyS-T XML.
- `MODULE_ID_MAX` is an optional upper bound on the assigned module IDs. This is useful to limit module ID bit-space.
- `OUTPUT_LIB` is an optional (`STATIC`) library target consisting of the `OUTPUT_CPP` file.
- `FORGET_OLD_IDS` is optional, and if present disregards the `STABLE_JSON` information.
- `GEN_STR_CATALOG` is optional, and allows pointing to a different python script.

=== Implementing a logger

Each logging implementation (configuration) provides a customization point: a
`logger` object, which must implement `log`. Therefore providing a custom
implementation is a matter of defining this structure appropriately.

[source,cpp]
----
struct my_logger_config {
  struct {
    template <typename Env, typename File, typename Line, typename FR>
    auto log(File, Line, FR const &fr) -> void {
      // log according to my mechanism
    }
  } logger;
};
----

Notice that the first template parameters to log is the
xref:logging.adoc#_logging_environments[environment].

The first two runtime parameters receive preprocessor `\_​_FILE_​\_` and
`__LINE_​_` values respectively. The `fr` argument is a
https://intel.github.io/cpp-std-extensions/#_ct_format_hpp[`stdx::format_result`]
structure containing a
https://intel.github.io/cpp-std-extensions/#_cts_t[compile-time format string]
and runtime arguments to be interpolated into it. One way to implement `log` is:

[source,cpp]
----
struct my_logger_config {
  struct {
    template <typename Env, typename File, typename Line, typename FR>
    auto log(File, Line, FR const &fr) -> void {
      constexpr auto fmtstr = std::string_view{decltype(fr.str)::value};
      fr.args.apply([&](auto const &...args) {
        ::fmt::print(fmtstr, args...);
      });
    }
  } logger;
};
----

In fact this is similar to how the `fmt` logger is implemented. To use the
custom implementation, as with any built-in choice of logger, specialize
`logging::config`:

[source,cpp]
----
template <>
inline auto logging::config<> = my_logger_config{};
----

=== Flavored logs

There is not always just one logging backend in an application. For example, you
might want regular logs and secure logs. Providing more backends is possible by specializing
`logging::config` with custom types.

[source,cpp]
----
struct secure_tag;

template <>
inline auto logging::config<secure_tag> = my_logger_config{};
----

And this backend can be used by defining macros in terms of the `logging::log`
function:

[source,cpp]
----
#define SECURE_TRACE(MSG, ...)                                  \
    logging::log<stdx::extend_env_t<cib_log_env_t,              \
        logging::get_flavor, stdx::type_identity<secure_t>{}>>( \
        __FILE__, __LINE__, stdx::ct_format<MSG>(__VA_ARGS__))

// etc
----

=== Modules

It can be helpful to scope or filter log messages by associating them with
module IDs. Several logging backends have support for this idea. Tagging every
log call site gets verbose and error-prone, so instead the approach taken by
`cib` is to override log modules by using `CIB_LOG_MODULE` declarations at
namespace, class or function scope.

[source,cpp]
----
auto global_f() {
  CIB_INFO("This log uses the default module ID");
}

namespace my_ns {
CIB_LOG_MODULE("my_ns");
CIB_INFO("This log uses my_ns as its module ID");

struct my_struct {
  CIB_LOG_MODULE("my_struct");

  auto f() {
    CIB_INFO("This log uses my_struct as its module ID");
  }

  auto g() {
    CIB_LOG_MODULE("g");
    CIB_INFO("This log uses g as its module ID");
  }
};
}
----

=== Version logging

To provide version information in a log, specialize the `version::config`
variable template. The configuration should provide a `build_id` and a
`version_string`.

[source,cpp]
----
struct my_version_config {
    constexpr static auto build_id = std::uint64_t{1234};
    constexpr static auto version_string = stdx::ct_string{"version"};
};

template <> inline auto version::config<> = my_version_config{};
----

Then use `CIB_LOG_VERSION()` to log the version. If the logging config provides
a `log_version` function, that will be used. Otherwise a text string will be
logged.

[source,cpp]
----
struct my_logger_config {
  struct {
    template <auto Version, stdx::ct_string S = ""> auto log_version() -> void {
      // log the build version according to my mechanism
    }
  } logger;
};
template <>
inline auto logging::config<> = my_logger_config{};

CIB_LOG_VERSION(); // calls my_logger_config::log_version
----

The easiest way to flavor the version logging is to define a macro in terms of
`CIB_LOG_V`:

[source,cpp]
----
#define LOG_SECURE_VERSION(...) CIB_LOG_V(secure_tag)
----

=== Logging environments

The logging environment is a compile-time map from types to values that allows a
logger to look up various parameters, including the module ID, the log level,
and the flavor. It can also be used to provide user-defined values to be
interpreted by a logging backend.

The macros that implement logging with various levels, modules, and flavors
are implemented as environment declarations, for example:
[source,cpp]
----
CIB_LOG_ENV(logging::get_level, logging::level::TRACE);
CIB_LOG("Hello");  // logs with TRACE level
----
or:
[source,cpp]
----
CIB_LOG_ENV(logging::get_flavor, secure_tag);
CIB_TRACE("Hello");  // logs with secure back end
----
A temporary override of values can be done with `CIB_WITH_LOG_ENV`:
[source,cpp]
----
CIB_WITH_LOG_ENV(logging::get_level, logging::level::TRACE,
                 logging::get_flavor, secure_tag) {
  CIB_LOG("Hello");  // logs a TRACE with secure back end
}
----

To interrogate the environment from a custom logger, use the appropriate query
on the environment.
[source,cpp]
----
struct my_logger_config {
  struct {
    template <typename Env, typename File, typename Line, typename FR>
    auto log(File, Line, FR const &fr) -> void {
      constexpr auto level = get_level(Env{}).value;
      // ...
    }
  } logger;
};
----

=== Queries

Much of the behavior of a log call can be customized using values queried from
an environment:

- https://github.com/intel/compile-time-init-build/blob/main/include/log/level.hpp[severity]
- https://github.com/intel/compile-time-init-build/blob/main/include/log/flavor.hpp[flavor] (typically secure or otherwise)
- https://github.com/intel/compile-time-init-build/blob/main/include/log/module.hpp[module]
- https://github.com/intel/compile-time-init-build/blob/main/include/log/unit.hpp[unit]
- https://github.com/intel/compile-time-init-build/blob/main/include/log/string_id.hpp[string ID] or https://github.com/intel/compile-time-init-build/blob/main/include/log/module_id.hpp[module ID]
- https://github.com/intel/compile-time-init-build/blob/main/include/log/catalog/builder.hpp[binary builder]
- https://github.com/intel/compile-time-init-build/blob/main/include/log/catalog/writer.hpp[binary writer]

The binary logger in particular can have both the builder and the writer
(destination) customized in this way. The defaults provide binary logging
according to the https://www.mipi.org/specifications/sys-t[MIPI Sys-T spec], but
any binary format can be provided by customizing the builder.

The string ID or module ID can also be fixed for a particular call, and the ID
generation process will heed IDs fixed in this way.

==== Runtime queries

If a query value is not known at compile time, it may be provided at runtime by
a function (non-capturing lambda expression). This is useful for the `unit`
value which is somewhat similar to `module`, but primarily intended to
distinguish between multiple runtime instances.

[source,cpp]
----
logging::mipi::unit_t my_unit = discover_unit();
CIB_LOG_ENV(logging::get_unit, [] { return my_unit; });
CIB_TRACE("Hello");
----

See the https://www.mipi.org/specifications/sys-t[MIPI Sys-T spec] for more
details.

=== Examples/How-Tos

I want to...

- ...use the fmt logger...
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/fmt_normal[...as my normal logger]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/fmt_tests[...in tests, to make sure my code logs correctly]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/fmt_multi[...to output to multiple places (stdout, file, etc)]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/fmt_custom_level[...with a custom level enumeration]
- ...use the binary logger...
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/binary_normal[...as my normal logger]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/binary_custom[...with my own binary format]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/binary_stable_ids[...and keep string IDs stable from build to build]
  * https://github.com/intel/compile-time-init-build/tree/main/examples/log/binary_fixed_id[...and fix a string ID in code]
- https://github.com/intel/compile-time-init-build/tree/main/examples/log/custom[...use my own logger]
- https://github.com/intel/compile-time-init-build/tree/main/examples/log/secure[...use a secure logger as well as a "normal" one]
